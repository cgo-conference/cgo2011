<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>2011 International Symposium on Code Generation and Optimization</title>
<link href="style.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" href="http://www.cgo.org/cgo2011/logo.ico" />
</head>
<body>
<div class="container">
<div class="text">
<img src="images/cgo-header.jpg">

<!--
<h1>Workshops</h1> 
<h2>Saturday, April 24, 2010<h2>

<table border="0" cellpadding="4">
<tr><td><td><S><B>Open64</B></s> <td><s><a href="http://dynopt.ece.udel.edu/open64/">Workshop on the Open64 Compiler</a></s> <font color="FF0000"><b>CANCELLED</b></tr>
<tr><td></tr>
<tr><td rowspan=2>Afternoon: <td rowspan=2><B>EPIC</B> <td> <a href="epic8/">Workshop on Explicitly Parallel Instruction Computing</a></tr>
<tr><td><a href="epic8/">Architectures and Compiler Technology</a></tr>
<tr><td></tr>
</table>
<br><br>
<h2>Sunday, April 25, 2010<h2>
<table border="0" cellpadding="4">
<tr><td></tr>
<tr><td>Morning: <td><B>WISH</B> <td> <a href="wish_workshop.html">Workshop on Infrastructures for Software/Hardware Co-design</a></tr>
<tr><td></tr>
<tr><td>Full-day: <td><B>ODES</B> <td> <a href="http://www.imec.be/odes/">Workshop on Optimizations for DSP and Embedded Systems</a></tr>
<tr><td></tr>
</table>
<BR><BR>
-->

<!--
<h1>CGO 2011 Call for Tutorial Proposals</h1>

<p>The Ninth ACM/IEEE International Symposium on Code Generation and
Optimization (CGO), located in Chamonix, France on April 2-6, 2011
solicits proposals for tutorials that will be co-located with the
main conference.</p>

<p>If you wish to organize a tutorial (half or full day), please e-mail a
proposal to the Tutorials Chair (Adam Welc, adam at adamwelc.net).</p>

<p>Please include in your proposal (no more than 2 pages):</p>

<ul>
   <li> Title of the tutorial
   <li> Organizers, their affiliations, and short bios </li>
   <li> Tutorial abstract, including its main objectives, target audience, and prerequisites </li>
   <li> Venue information (e.g., conference name and year) for previous presentations of the tutorial, if any </li>
   <li> Expected duration (i.e., half day or full day) </li>
   <li> Expected attendance (based on historical data or experience) </li>
   <li> Expected tutorial format (e.g., lecture, lecture+demo, hands-on exercises, etc.) </li>
   <li> Any special requirements the tutorial may have </li>
</ul>

<h3>Important Dates</h3>
<p>Proposal Submission: December 3rd, 2010<br>
   Notification Date:   December 10th, 2010
-->

<h1>Tutorials</h1>

<h2>Schedule</h2>
<h3>Saturday April 2, 2011</h3>
<table id="schedule">
<tr>
<th class="space"></th><th>T. BOURRIT</th><th>P. PAYOT</th><th>I. STRATON</th><th>SAMIVEL</th><th>G. LOPPE</th><th>J. VALLOT</th>
</tr>
<tr>
  <td class="time">Morning<br><small>08:00-12:00</small></a></td>
  <td class="tutorial"><a href="tutorials.php.html#GCC">GCC</a></td>
  <td class="tutorial"><a href="tutorials.php.html#PARALLEL">Parallel</a></td>
  <td class="workshop" rowspan="2"><a href="http://researchr.org/conference/wir-2011">WIR-1</a></td>
  <td></td>
  <td class="workshop" rowspan="2"><a href="http://www.imec.be/odes/">ODES-9</a></td>
  <td></td>
</tr>
<tr>
  <td class="time">Afternoon<br><small>14:00-18:00</small></a></td>
  <td class="tutorial"><a href="tutorials.php.html#ALPHAZ">AlphaZ</a></td>
  <td class="tutorial"><a href="tutorials.php.html#LOOPVECT">LoopVect</a></td>
  <!--  <td class="workshop"><a href="http://researchr.org/conference/wir-2011">WIR-1</a></td> -->
  <td class="workshop"><a href="http://www.lsc.ic.unicamp.br/wish11/">WISH-3</a></td>
  <!-- <td class="workshop"><a href="http://www.imec.be/odes/">ODES-9</a></td> -->
  <td class="tutorial"><a href="tutorials.php.html#X10">X10</a></td>
</tr>
</table>

<h3>Sunday April 3, 2011</h3>
<table id="schedule">
<tr>
<th class="space"></th><th>T. BOURRIT</th><th>P. PAYOT</th><th>I. STRATON</th><th>SAMIVEL</th><th>G. LOPPE</th><th>J. VALLOT</th>
</tr>
<tr>
  <td class="time">Morning<br><small>08:00-12:00</small></a></td>
  <td class="workshop" rowspan="2"><a href="http://grow2011.inria.fr">GROW-3</a></td>
  <td class="workshop"><a href="http://impact2011.inrialpes.fr/home">IMPACT-1</a></td>
  <td class="workshop"><a href="http://ctuning.org/workshop-smart11">SMART-5</a></td>
  <td class="tutorial"><a href="tutorials.php.html#PIN">Pin!</a></td>
  <td class="tutorial"><a href="tutorials.php.html#WCC">WCC</a></td>
  <td></td>
</tr>
<tr>
  <td class="time">Afternoon<br><small>14:00-18:00</small></a></td>
  <!--  <td class="workshop"><a href="http://grow2011.inria.fr">GROW-3</a></td> -->
  <td class="tutorial"><a href="tutorials.php.html#ARBB">ArBB</a></td>
  <td class="workshop"><a href="http://acca2011.imag.fr">ACCA-1</a></td>
  <td class="tutorial"><a href="tutorials.php.html#DYRIO">DyRIO</a></td>
  <td class="tutorial"><a href="tutorials.php.html#PIPS">PIPS</a></td>
  <td></td>
</tr>
</table>

<br>
<table>
<tr>
<td>
<b>Rooms:</b>
</td>
<td>
<a href="rooms.php.html"><img width=30% src="rooms.png"></a>
</td>
</tr>
</table>



<!--  ============================================================================================================================================  -->
<hr>
<a name="ARBB"></a>
<h2>[ArBB] Array Building Blocks: A Dynamic Compiler for Data-parallel Heterogeneous Systems</h2>

<p><b>summary:</b><br>
Hardware platforms are getting harder to program effectively, as they grow in
complexity to include multiple cores, SIMD hardware, accelerators (e.g. GPUs and
Intel's Knights Ferry - formerly Larrabee) and even clustering support.  The
challenge is to provide an efficient means of exploiting parallel performance to
the masses of novice programmers.  At least two things are required to solve
this problem: 1) a language interface that enables ease of use without the
perils of parallel programming, and 2) a compiler infrastructure that takes a
high-level specification of what to do, and portably maps it onto a variety of
heterogeneous hardware targets.<br>

This tutorial uses Intel's newly-released Array Building Blocks (ArBB) to
illustrate the challenges and potential solutions in this space.  ArBB is a
dynamic compiler infrastructure that can compile or JIT for both SIMD and thread
parallelism on symmetric multi-processor, distributed, and accelerator
targets.  Parallelism is exposed to this infrastructure via an embedded
language, e.g. a library-based C++ API, using aggregate data types and
operators.  It enables safety and debuggability by construction.  It allows
applications with kernels that are recoded with minimized effort to be compiled
once using standard compilers, and then be dynamically retargeted to platforms
that haven't even been invented yet by simply switching runtime libraries.  We
put ArBB in the context with a variety of other programming models, including
CUDA and OpenCL.<br>

This tutorial may be of practical interest to language experts who are
interested in parallel language design, to educators who may want to leverage
this material to teach parallel programming models for emerging architectures,
and to practitioners who may benefit from our experience implementing compilers
to address customer-driven concerns.  The presentation of new language features,
application examples, optimization techniques that enable efficient offload to
accelerators, and the demonstration of speedup and debugging support on both
standard laptops and pre-production acceleration hardware are some of the
aspects of this tutorial that could draw participation.<br>
<a href="arbb/CGO%202011%20ArBB%20Tutorial%20Posting.pdf" target="_blank">More details</a>
</p>

<p><b>presenters:</b><br>
 Chris J. Newburn (CJ), Intel
</p>

<!--  ============================================================================================================================================  -->
<hr>
<a name="DYRIO"></a>
<h2>[DyRIO] Building Dynamic Instrumentation Tools with DynamoRIO</h2>
<p><b>summary:</b><br>
 This tutorial will present the DynamoRIO tool platform and describe how
 to use its API to build custom tools that utilize dynamic code
 manipulation for instrumentation, profiling, analysis, optimization,
 introspection, security, and more.  The DynamoRIO tool platform was first
 released to the public in June 2002 and has since been used by many
 researchers to develop systems ranging from taint tracking to prefetch
 optimization.  DynamoRIO is now publicly available in open source form.<br>

 The first part of the tutorial will consist of presentations that
 describe the full range of DynamoRIO's powerful API, which abstracts away
 the details of the underlying infrastructure and allows the tool builder
 to concentrate on analyzing or modifying the application's runtime code
 stream.  We will give many examples and highlight differences between
 DynamoRIO and other tool platforms.  We will also seek feedback on how we
 can improve the DynamoRIO API.<br>

 The second part of the tutorial will include lab sessions where attendees
 experiment with building their own tools using DynamoRIO.  Attendees for
 should bring a laptop with a Linux or Windows development environment:
 gcc on Linux, Visual Studio on Windows, as well as CMake (which can be
 installed at the tutorial if necessary).<br>
<a href="http://dynamorio.org/tutorial.html" target="_blank">More details</a>
</p>

<p><b>presenters:</b><br>
Derek Bruening<br>
Qin Zhao
</p>


<!--  ============================================================================================================================================  -->
<hr>
<a name="GCC"></a>
<h2>[GCC] Essential Abstractions in GCC</h2>

<p><b>summary:</b><br>
The GNU Compiler collection is a compiler generation framework which constructs
a compiler for a given architecture by reading the machine descriptions for that
architecture. This framework is practically very useful as evidenced by the
existence of several dozens of targets for which compilers have been created
using GCC. These compiler are routinely used by millions of users for their
regular compilation needs. While a deployment of GCC on the default parameters
is easy, any other customization, experimentation and modification of GCC is
difficult and requires a high amount of expertise and concentrated efforts.  In
this tutorial we describe some carefully chosen abstractions that help one to
understand the retargetability mechanism and the architecture of the compiler
generation framework of GCC and relate it to a generated compiler.<br>

A summary of topics covered:
<ul>
<li>meeting the challenge of understanding GCC</li>
<li>the architecture of GCC</li>
<li>generating a compiler from GCC</li>
<li>the structure of a GCC generated compiler</li>
<li>first level graybox probing of the compilation sequence of a GCC generated compiler</li>
<li>plugin structure of GCC to hook in front ends, optimization passes, and back end</li>
<li>introduction to machine descriptions</li>
<li>retargetability and instruction selection mechanism of GCC</li>
</ul>
<a href="http://www.cse.iitb.ac.in/grc/index.php?page=gcc-tut" target="_blank">More details</a>
</p>

<p><b>presenters:</b><br>
Uday P. Khedker
</p>

<!--  ============================================================================================================================================  -->
<hr>
<a name="PARALLEL"></a>
<h2>[Parallel] GPU Programming Models, Optimizations and Tuning</h2>

<p><b>summary:</b><br>
GPU based parallel computing is of tremendous interest today because of their
significantly higher peak performance than general-purpose multicore
processors,
as well as better energy efficiency. However, harnessing the power of GPUs is
more complicated than general-purpose multi-cores. There has been considerable
recent interest in two complementary approaches to assist application
developers:
<ul>
<li>programming models that explicitly expose the programmer to parallelism; and</li>
<li>compiler optimization and tuning frameworks to automatically transform programs for parallel execution on GPUs.</li>
</ul>
This tutorial will provide an introductory survey covering both these aspects.<br>
<a href="http://www.ece.lsu.edu/jxr/cgo11-tutorial/" target="_blank">More details</a>
</p>

<p><b>presenters:</b><br>
J. (Ram) Ramanujam, Department of Electrical and Computer Engineering, Louisiana State University<br>
P. (Saday) Sadayappan, Department of Computer Science and Engineering, Ohio State University
</p>

<!--  ============================================================================================================================================  -->
<hr>
<a name="PIN"></a>
<h2>[Pin!] Detailed Pin!</h2>

<p><b>summary:</b><br>
Pin is a dynamic instrumentation system provided by Intel
(http://www.pintool.org), which allows C/C++ introspection code to be injected
at arbitrary places in a running executable. The injected introspection code is
referred to as a Pin tool and is used to observe the behavior of the program.
Pin tools can be writtten to perform various functionalities including
application profiling, memory leak detection, trace generators for the IA32,
Intel64 and IA64 (Itanium) platforms, running either Windows or Linux. Pin
provides a rich API that abstracts away the underlying instruction set
idiosyncrasies and allows context information such as register contents to be
passed to the injected code as parameters. Pin automatically saves and restores
registers that are overwritten by the injected code so the application continues
to execute normally. Pin makes it easy to do studies on complex real-life
applications, which makes it a useful tool not only for research, but also for
education. Pin has been downloaded tens of thousands times, has been cited in
over 700 publications, and has over 550 registered mailing list users.<br>

The tutorial targets researchers, students, and educators alike, and provides a
detailed look at Pin, both how to use Pin and how Pin works. Participants will
obtain a good undersanding of the Pin API ans. The tutorial is comprised of four
learning components. The first component provides insight into the workings of
Pin, and introduces its fundamental instrumentation structures and concepts thru
example Pin tools. The second component will present methods and considerations
for writing optimal Pintools. The third component introduces useful Pin-based
tools that are freely available for download, in particular we will look in
detail at the memtrace and membuffer tools, which implement the instrumentation
basis for algorithms which need to examine memory accesses. The fourth component
will present some of the more advanced Pin APIs, such as signal/exception
interception, multi threaded pin tools, Pin interface to debuggers.<br>
<a href="pin/cgo2011.htm" target="_blank">More details</a>
</p>

<p><b>presenters:</b><br>
Tevi Devor, Staff Engineer,  Intel<br>
Robert Cohn, Senior Principal Engineer, Intel
</p>


<!--  ============================================================================================================================================  -->
<hr>
<a name="PIPS"></a>
<h2>[PIPS] PIPS: An Interprocedural Extensible Source-to-Source Compiler Infrastructure for Code/Application Transformations and Instrumentations</h2>

<p><b>summary:</b><br>
The PIPS compiler framework was designed in 1988 at MINES ParisTech to
research interprocedural parallelization. It has been used to generate
automatic code distribution, OpenMP-to-MPI code translation, HPF
Compiler, automatic C and Fortran to CUDA translation, code
modelization for graphic IDEs, genetic algorithm-based optimizations,
SIMD (SSE, AVX...) portable code generation and code optimization for
FPGA-based accelerators. PIPS supports entire Fortran 77 and C
applications and is easily extensible. After 20 years of development
and constant improvement, PIPS is a robust source-to-source compiler,
providing a large set of program analyses and transformations with
around 300 phases.<br>
<a href="http://pips4u.org/conferences/pips-tutorial-at-cgo-2011" target="_blank">More details</a>
</p>

<p><b>presenters:</b><br>
Corinne Ancourt, Centre de Recherche en Informatique, MINES ParisTech, France<br>
Serge Guelton, Telecom Bretagne/Info/HPCAS, France<br>
Ronan Keryell, CSO, HPC Project, France<br>
Frederique Silber-Chaussumier, Telecom Sud Paris, France
</p>

<!--  ============================================================================================================================================  -->
<hr>
<a name="ALPHAZ"></a>
<h2>[AlphaZ] AlphaZ and the Polyhedral Equational Model </h2>

<p><b>summary:</b><br>
The polyhedral model is now established as a powerful, "domain-specific"
model for program representation, analysis, and transformation.  It is limited
to a small domain (commonly called affine-control loops) for which it provides
a very powerful abstraction.  This tutorial will present, in a hands-on manner
two aspects of the model that are not very widely known.  The first is the
*equational* aspect of the polyhderal model, where high level equations are
used to describe polyhderal computations, and the powerful static analyses
that are enabled by this declarative view.  The second is exposure to an open
source, research tool, AlphaZ that is designed in a modular maner to be very
highly extensible.  Participants will have the opportunity to write simple
program transformations themselves.<br>
<a href="alphaz/polyhedral-posting.pdf" target="_blank">More details</a>
</p>

<p><b>presenters:</b><br>
S. Rajopadhye, Colorado State University
</p>


<!--  ============================================================================================================================================  -->
<hr>
<a name="LOOPVECT"></a>
<h2>[LoopVect] Program Optimization through Loop Vectorization </h2>

<p><b>summary:</b><br>
Most modern microprocessors contain vector extension that benefit from the fine
grain parallelism of vector operations. Programmers can take advantage of these
extensions through vectorizing compilers or by explicitly programming them with
intrinsics. A significant fraction of the peak performance of many of today's
machines can be attributed to their vector extensions.<br>
This tutorial covers techniques to make the best possible use of vector
extensions. We will discuss:
<ul>
<li>Compiler limitations and the manual transformations that the programmer must apply to overcome compiler limitations.</li>
<li>The use of intrinsics to explicitly program vector extensions.</li>
</ul>

Compiler limitations and manual transformations will be illustrated using code
snippets from real applications and common kernels processed by the IBM xlc and
INTEL icc compilers. The report generated by the compiler, execution time and
speedups obtained from vectorization will be shown in each case. The source
code of all the examples will be distributed, so that attendees can run the examples
and measure their performance on their own machines.
The only pre-requisite for this language is familiarity with the C language.<br>
<a href="http://polaris.cs.uiuc.edu/~garzaran/cgo11/index.htm" target="_blank">More details</a>
</p>

<p><b>presenters:</b><br>
Maria J. Garzaran, Research Assistant Professor, Computer Science Department University of Illinois at Urbana-Champaign<br>
David Padua, Donald Biggar Willet Professor, Computer Science Department University of Illinois at Urbana-Champaign
</p>

<!--  ============================================================================================================================================  -->
<hr>
<a name="WCC"></a>
<h2><a name="WCC"><strike>[WCC] Reconciling Compilers and Timing Analysis for Safety-Critical Real-Time Systems - the WCET-aware C Compiler WCC</strike> </a></h2>

<span style="color: black; font-weight: bold; background-color: orange; font-size: normal;">
WARNING: tutorial canceled due to personal emergency for one of the organizers - our apologies
</span>

<p><b>summary:</b><br>
Timing constraints must be respected for safety-critical real-time
applications. Traditionally, compilers are unable to use precise estimates of
execution times for optimization, and timing properties of code are derived
after compilation. A number of design iterations are required if timing
constraints are not met. We propose to reconcile compilers and timing analysis
and to create a worst-case execution time (WCET) aware compiler in this way.
Such WCET-aware compilers can exploit precise WCET information during
compilation. This way, they are able to improve the code quality. Also, we may
be able to avoid some of the design iterations.<br>

In this tutorial, we present the integration of a compiler and a WCET
analyzer, yielding our WCET-aware compiler WCC. We are then considering
compiler optimizations for their potential to reduce the WCET, assuming that
the WCET is now used as the cost function. Considered optimizations include
loop unrolling, register allocation, scratchpad memory allocation, memory
content selection and cache partitioning for multi-task systems. For large
sets of benchmarks, average WCET reductions of up to 40% were achieved. The
results indicate that this new area of research has the potential of achieving
worthwhile execution time reductions for safety-critical real-time code.<br>
<a href="http://ls12-www.cs.tu-dortmund.de/research/activities/wcc/tutorials/cgo11/index.html" target="_blank">More details</a>
</p>

<p><b>presenters:</b><br>
Heiko Falk, TU Dortmund, Germany<br>
Peter Marwedel, TU Dortmund, Germany
</p>


<!--  ============================================================================================================================================  -->
<hr>
<a name="X10"></a>
<h2>[X10] Inside X10: Implementing a High-level Language on Distributed and Heterogeneous Platforms</h2>

<p><b>summary:</b><br>
X10 is a type-safe, modern, parallel, distributed
      object-oriented language designed specifically to address the
      challenges of productively programming complex hardware systems
      consisting of clusters of multicore CPUs and accelerators.
      A single X10 source program can be compiled for efficient
      execution on a wide variety of target platforms including single
      machines running Linux, MacOS, or Windows; clusters of x86 and
      Power based SMP nodes; BlueGene/P supercomputers; and
      CUDA-enabled GPUs.<br>

      Implementing a high-level language like X10 on a variety of
      platforms and achieving high performance presents a number of
      challenges. In this tutorial we will briefly cover the core
      features of the X10 language and some current empirical
      results, but will mainly focus on presenting the implementation
      technology that underlies the system. Topics covered will
      include:
<ul>
<li>an overview of the X10 compiler and runtime system</li>
<li>a generalization of Cilk-style workstealing for non-strict task graphs</li>
<li>compilation of X10 to CUDA-enabled GPUs</li>
<li>optimization of specific X10 language features</li>
</ul>
      The tutorial is intended both for people who are generally
      interested in the implementation technology used by X10 and
      other similar PGAS languages and at researchers who are
      interested in using the X10 implementation (available open
      source at x10-lang.org) as the basis for their own research
      projects.<br>
<a href="x10/x10-posting.pdf" target="_blank">More details</a>
</p>

<p><b>presenters:</b><br>
Olivier Tardieu, IBM Research<br>
David Cunningham, IBM Researchu<br>
Igor Peshansky, IBM Research
</p>


</div>


<div class="menu">
<a href="index.php.html">Home</a>
<a class=DONE href="call_papers.php.html">Call for Papers</a>
<a href="committees.php.html">Committees</a>
<a href="hotels.php.html">Hotels</a>
<a href="keynotes.php.html">Keynotes</a>
<a href="venue.php.html">Local Information</a>
<a href="gallery.php.html">Photo Gallery</a>
<a href="program.php.html">Program</a>
<a href="registration.php.html">Registration</a>
<a href="social.php.html">Social Event</a>
<a href="sponsors.php.html">Sponsors</a>
<a href="posters.php.html">Student Posters</a>
<a class=DONE href="submissions.php.html">Submission</a>
<a href="travel.php.html">Travel Information</a>
<a href="travel_support.php.html">Travel Support</a>
<a href="tutorials.php.html">Tutorials</a>
<a href="workshops.php.html">Workshops</a>
<a href="past.php.html">Past Conferences</a>
<a target="_blank" href="charter.html">CGO Charter</a>
</div>

</div>
</body>
</html>
